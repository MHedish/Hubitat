/*
*  RainBird LNK WiFi Module Driver
*
*  Copyright 2025 MHedish
*  Licensed under the Apache License, Version 2.0
*  https://www.apache.org/licenses/LICENSE-2.0
*
*  https://paypal.me/MHedish
*
*  Changelog:
*  0.0.1.0   -- Initial version.  Controls Rainbird irrigation zones directly via HTTP.  Supports automatic per-zone shutdown after runtime expires.
*  0.0.2.0   -- Added controller date/time refresh and setting capabilities.
*  0.0.2.1   -- Integrated standardized logging and driverInfoString() methods.
*  0.0.2.2   -- Updated lifecycle methods to MHedish standard (installed/updated/configure/initialize).
*/

import groovy.transform.Field

@Field static final String DRIVER_NAME     = "RainBird LNK WiFi Module Controller"
@Field static final String DRIVER_VERSION  = "0.0.2.2"
@Field static final String DRIVER_MODIFIED = "2025.10.13"

metadata {
    definition (name: DRIVER_NAME, namespace: "mhedish", author: "MHedish") {
        capability "Initialize"
        capability "Refresh"
        capability "Actuator"
        capability "Sensor"

        command "startZone", ["number", "number"]
        command "stopZone", ["number"]
        command "stopAll"
        command "setRainDelay", ["number"]
        command "getControllerTime"
        command "getControllerDate"
        command "setControllerTime"
        command "setControllerDate"

        attribute "controllerStatus", "string"
        attribute "lastUpdated", "string"
        attribute "rainDelay", "number"
        attribute "controllerTime", "string"
        attribute "controllerDate", "string"
        attribute "driverInfo", "string"
    }

    preferences {
        input name: "ipAddress", type: "text", title: "Rainbird Controller IP", required: true
        input name: "password", type: "password", title: "Rainbird Controller Password", required: true
        input name: "zoneCount", type: "number", title: "Number of Zones", defaultValue: 6, range: "1..16"
        input name: "refreshInterval", type: "number", title: "Refresh Interval (seconds)", defaultValue: 300, range: "60..3600"
        input name: "autoTimeSync", type: "bool", title: "Automatically sync Hubitat â†’ RainBird time", defaultValue: false
        input name: "logEnable", type: "bool", title: "Enable Debug Logging", defaultValue: true
        input name: "logEvents", type: "bool", title: "Enable Info/Event Logging", defaultValue: true
    }
}

/* ===============================
   Lifecycle
   =============================== */
def installed(){ logInfo "Installed"; initialize() }
def updated() { logInfo "Preferences updated"; configure() }
def configure() { logInfo "${driverInfoString()} configured"; initialize() }
def initialize(){
    logInfo "${driverInfoString()} initializing..."
    emitEvent("driverInfo", driverInfoString())
    state.zoneTimers = [:]
    refresh()
    scheduleRefresh()
    if (autoTimeSync) runEvery6Hours(setControllerTime)
}

/* ===============================
   Zone Control
   =============================== */
def startZone(zoneNumber, durationSeconds) {
    logInfo "Starting zone ${zoneNumber} for ${durationSeconds}s"
    def body = [command:"water_now", zone:zoneNumber, duration:durationSeconds]
    sendRainbirdCommand("/api/water_now", body)
    sendEvent(name:"zone${zoneNumber}Status", value:"running")
    unschedule("stopZone_${zoneNumber}")
    runIn(durationSeconds, "stopZone_${zoneNumber}")
    state.zoneTimers[zoneNumber] = now() + (durationSeconds * 1000L)
}
(1..16).each { z -> this.metaClass."stopZone_${z}" = { -> stopZone(z) } }

def stopZone(zoneNumber) {
    logInfo "Stopping zone ${zoneNumber}"
    sendRainbirdCommand("/api/stop_zone", [command:"stop_zone", zone:zoneNumber])
    sendEvent(name:"zone${zoneNumber}Status", value:"stopped")
    state.zoneTimers.remove(zoneNumber)
}

def stopAll() {
    logInfo "Stopping all zones"
    sendRainbirdCommand("/api/stop_all", [:])
    (1..(zoneCount ?: 6)).each { z -> sendEvent(name:"zone${z}Status", value:"stopped") }
}

/* ===============================
   Rain Delay
   =============================== */
def setRainDelay(hours) {
    logInfo "Setting rain delay for ${hours} hours"
    sendRainbirdCommand("/api/set_rain_delay", [hours:hours])
    sendEvent(name:"rainDelay", value:hours)
}

/* ===============================
   Time / Date
   =============================== */
def getControllerTime() {
    logInfo "Requesting current controller time..."
    sendRainbirdCommand("/api/current_time", [:])
}
def getControllerDate() {
    logInfo "Requesting current controller date..."
    sendRainbirdCommand("/api/current_date", [:])
}
def setControllerTime() {
    def nowLocal = new Date()
    def formatted = nowLocal.format("HH:mm:ss", location.timeZone)
    logInfo "Setting controller time: ${formatted}"
    sendRainbirdCommand("/api/set_time", [time:formatted])
}
def setControllerDate() {
    def nowLocal = new Date()
    def formatted = nowLocal.format("yyyy-MM-dd", location.timeZone)
    logInfo "Setting controller date: ${formatted}"
    sendRainbirdCommand("/api/set_date", [date:formatted])
}

/* ===============================
   Refresh & Scheduling
   =============================== */
def refresh() {
    logDebug "Refreshing Rainbird controller status..."
    sendRainbirdCommand("/api/status", [:])
    getControllerTime()
    getControllerDate()
}
private scheduleRefresh() {
    def seconds = refreshInterval ?: 300
    logInfo "Scheduling automatic refresh every ${seconds}s"
    runEvery${seconds}Seconds(refresh)
}

/* ===============================
   Communication
   =============================== */
private sendRainbirdCommand(endpoint, body) {
    def params = [
        uri: "http://${ipAddress}${endpoint}",
        contentType: "application/json",
        body: body,
        headers: ["Authorization": "Basic ${"${password ?: ''}".bytes.encodeBase64().toString()}"]
    ]
    try {
        httpPost(params) { resp ->
            if (resp?.status == 200 && resp?.data) handleResponse(resp.data)
            else logWarn "Unexpected response: ${resp?.status}"
        }
    } catch (e) {
        logError "HTTP request failed: ${e.message}"
        sendEvent(name:"controllerStatus", value:"error")
    }
}

/* ===============================
   Response Handler
   =============================== */
private handleResponse(data) {
    logDebug "Processing Rainbird response: ${data}"
    if (data?.time)  sendEvent(name:"controllerTime", value:data.time)
    if (data?.date)  sendEvent(name:"controllerDate", value:data.date)
    if (data?.zones) {
        data.zones.each { zone ->
            sendEvent(name:"zone${zone.id}Status", value:(zone.running ? "running" : "stopped"))
        }
    }
    sendEvent(name:"lastUpdated", value:new Date().format("yyyy-MM-dd HH:mm:ss", location.timeZone))
}

/* ===============================
   Logging & Driver Info Utilities
   =============================== */
private driverInfoString() { return "${DRIVER_NAME} v${DRIVER_VERSION} (${DRIVER_MODIFIED})" }
private logDebug(msg) { if (logEnable) log.debug "[${DRIVER_NAME}] $msg" }
private logInfo(msg)  { if (logEvents) log.info  "[${DRIVER_NAME}] $msg" }
private logWarn(msg)  { log.warn "[${DRIVER_NAME}] $msg" }
private logError(msg) { log.error "[${DRIVER_NAME}] $msg" }

/* ===============================
   Event Utility
   =============================== */
private emitEvent(name, value) {
    sendEvent(name:name, value:value)
    logDebug "Event sent: ${name} = ${value}"
}
