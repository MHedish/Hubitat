/*
*  RainBird LNK WiFi Module Driver
*  Copyright 2025 Marc Hedish
*  Licensed under the Apache License, Version 2.0
*  https://www.apache.org/licenses/LICENSE-2.0
*
*  https://paypal.me/MHedish
*
*  Changelog:
*  0.0.1.x  –– Legacy   –– Initial direct HTTP control implementation
*  0.0.2.x  –– Stable   –– Added encrypted transport and telemetry foundation
*  0.0.3.x  –– Mature   –– Dynamic controller adaptation and full opcode coverage
*  0.0.4.x  –– Reverted –– Asynchronous command experiment rolled back
*  0.0.5.x  –– Refactor –– Stability, pacing, and lifecycle optimization
*  0.0.6.x  –– Stable   –– Deterministic time sync and drift correction
*  0.0.7.0  –– Hardened initialization sequence; reconnoiter held through identity and scheduling to eliminate re-entrant refresh during preference updates.
*  0.0.7.1  –– Refined event telemetry phrasing; standardized exception handling (catch(e)) for consistency; improved sync reporting clarity.
*  0.0.7.2  –– Renamed “Protocol Version” to “Firmware Version” for clarity; streamlined attribute set for improved telemetry focus and readability.
*  0.0.7.3  –– Removed redundant pre/post error pauses from sendRainbirdCommand(); finalized non-blocking, adaptive pacing model.
*  0.0.7.4  –– Hardened backoff handling: reconnoiter-aware recovery prevents infinite refresh retries and ensures deterministic recovery from network instability.
*  0.0.7.5  –– Added “Manual” refresh mode (interval 0); skips CRON scheduling for on-demand or rule-based refresh operation.
*  0.0.7.6  –– Added hourly clock synchronization under Manual refresh mode; ensures continuous drift correction when autoTimeSync is enabled.
*  0.0.7.7  –– Added CommandSupportRequest (0x04) and full diagnostic suite testAllSupportedCommands(); emitEvent telemetry replaces attribute comparison for non-persistent command validation.
*  0.0.7.8  –– Added extended refresh intervals (2h, 4h, 8h); scheduler now dynamically adjusts CRON format for minute- or hour-based refresh modes.
*  0.0.7.9  –– Fixed controller state reconciliation; refresh() now properly updates irrigationState and controllerState post-stop without conditional suppression.
*  0.0.7.10 –– Refined runProgram() NAK handling; now warns if program is undefined or contains no zones, matching controller behavior for Program D and empty programs.
*  0.0.7.11 -- Reverted
*  0.0.7.12 -- Reverted
*  0.0.7.13 –– Added transient cmdBusy lock to prevent overlapping commands (fixes rare 503 race).
*  0.0.7.14 –– Fixed runIn() closure bug; restored automatic self-recovery/backoff after network instability.
*  0.0.7.15 –– Internal optimization: replaced user-facing refreshGuardSeconds with fixed REFRESH_GUARD_MS constant (15s default) for cleaner, self-documenting debounce protection.
*  0.0.7.16 –– Added full program schedule retrieval (0x36/0x38/0x3A) with decoded days, start times, and zone lists for Programs A–D; standardized program map usage across all functions.
*  0.0.7.18 –– Adjusted parseProgramDays()/parseProgramZones() for legacy 2.x short responses (6 chars); prevents substring range errors and correctly decodes compact masks.
*  0.0.7.20 –– Finalized legacy-firmware schedule parsing; 2.x short-form responses now decode days and zones reliably; Unified commandSupport() → getCommandSupport(), hardened refresh() logic, and added adaptive parsing for 0x36/38/3A.
*  0.0.7.22 –– Added boolean programScheduleSupport attribute for RM/WC compatibility; updated getProgramSchedule() and getAllProgramSchedules() to use emitEvent for static reporting and improved legacy stub detection.
*  0.0.7.23 –– Fixed null firmwareVersion reference in getProgramSchedule(); log now resolves via device.currentValue() for deterministic attribute access.
*  0.0.7.24 –– Reduced event noise in getProgramSchedule(); removed redundant “Unsupported” attribute emits for cleaner logs and deterministic reporting.
*  0.0.7.26 –– Fixed Groovy scope binding issue causing ${prog} interpolation loss within getProgramSchedule().
*/

import groovy.transform.Field
import groovy.json.JsonOutput
import groovy.json.JsonSlurper
import java.security.MessageDigest
import javax.crypto.Cipher
import javax.crypto.spec.SecretKeySpec
import javax.crypto.spec.IvParameterSpec
import java.io.ByteArrayOutputStream

@Field static final String DRIVER_NAME     = "RainBird LNK WiFi Module Controller"
@Field static final String DRIVER_VERSION  = "0.0.7.26"
@Field static final String DRIVER_MODIFIED = "2025.11.04"
@Field static final String PAD = "\u0016"
@Field static final int BLOCK_SIZE = 16
@Field static int delayMs=150
@Field static int minDelay=50
@Field static int maxDelay=500
@Field static int successStreak=0
@Field static Boolean reconnoiter=false
@Field static Long lastRefreshEpoch=0
@Field static Boolean cmdBusy = false
@Field static final Integer REFRESH_GUARD_MS=15000 // debounce window (15s default; extend to 45000ms if needed)
@Field static final MessageDigest SHA256=MessageDigest.getInstance("SHA-256")
@Field static final Cipher AES_CIPHER=Cipher.getInstance("AES/CBC/NoPadding", "SunJCE")

metadata {
    definition(
        name: DRIVER_NAME,
        namespace: "MHedish",
        author: "Marc Hedish",
        importUrl: "https://raw.githubusercontent.com/MHedish/Hubitat/refs/heads/main/Drivers/RainBird-LNK/RainBird-LNK-Wi-Fi-Module"
    ) {
        capability "Actuator"
        capability "Initialize"
        capability "Refresh"
        capability "Sensor"

        attribute "activeZone", "number"
        attribute "autoTimeSync", "boolean"
        attribute "availableStations", "string"
        attribute "clockDrift", "number"
        attribute "controllerDate", "string"
        attribute "controllerTime", "string"
        attribute "delaySetting", "number"
        attribute "driverInfo", "string"
        attribute "driverStatus", "string"
        attribute "firmwareVersion", "string"
        attribute "irrigationState", "string"
		attribute "lastEventTime", "string"
        attribute "lastSync", "string"
        attribute "model", "string"
        attribute "programScheduleSupport", "boolean"
        attribute "rainDelay", "number"
		attribute "rainSensorState", "string"
        attribute "remainingRuntime", "number"
        attribute "seasonalAdjust", "number"
        attribute "serialNumber", "string"
		attribute "waterBudget", "number"
        attribute "watering", "boolean"
		attribute "zoneAdjustments", "string"
        attribute "zoneCount", "number"

        command "configure"
        command "disableDebugLoggingNow"
        command "setRainDelay",[[name:"Rain Delay (0–14 days) ",type:"NUMBER"]]
        command "runProgram",[[name: "program",type: "ENUM",description: "Select Rain Bird program to run manually ",constraints: ["A", "B", "C", "D"]]]
        command "runZone",[[name:"Zone Number ",type:"NUMBER"],[name:"Duration (minutes) ", type:"NUMBER"]]
        command "stopZone",[[name:"Zone Number",type:"NUMBER"]]
        command "stopIrrigation"
        command "getAllProgramSchedules"
        command "testAllSupportedCommands",[[name:"Diagnostic: Validate supported LNK commands."]]
    }

    preferences {
        input("ipAddress","text",title:"RainBird Controller IP",required:true)
        input("password","password",title:"RainBird Controller Password",required:true)
        input("zonePref","number",title:"Number of Zones", defaultValue:6,range:"1..16")
        input("autoTimeSync","bool",title:"Automatically sync RainBird to Hubitat clock",defaultValue:true)
        input("logEnable","bool",title:"Enable Debug Logging",defaultValue:false)
        input("logEvents","bool",title:"Log All Events",defaultValue:false)
        input name:"refreshInterval", type:"enum", title:"Refresh Interval",defaultValue:"5",
		    options:[
		        "0":"Manual","1":"Every minute","2":"Every 2 minutes","3":"Every 3 minutes",
		        "4":"Every 4 minutes","5":"Every 5 minutes","10":"Every 10 minutes","15":"Every 15 minutes",
		        "20":"Every 20 minutes","30":"Every 30 minutes","45":"Every 45 minutes","60":"Every hour",
		        "120":"Every 2 hours","240":"Every 4 hours","480":"Every 8 hours"
		    ]
    }
}

/* =============================== Logging & Utilities =============================== */
private driverInfoString(){return"${DRIVER_NAME} v${DRIVER_VERSION} (${DRIVER_MODIFIED})"}
private logDebug(msg){if(logEnable)log.debug"[${DRIVER_NAME}] $msg"}
private logInfo(msg){if(logEvents)log.info"[${DRIVER_NAME}] $msg"}
private logWarn(msg){log.warn"[${DRIVER_NAME}] $msg"}
private logError(msg){log.error"[${DRIVER_NAME}] $msg"}
private emitEvent(String n,def v,String d=null,String u=null){sendEvent(name:n,value:v,unit:u,descriptionText:d);if(logEvents)log.info"[${DRIVER_NAME}] ${d?"${n}=${v} (${d})":"${n}=${v}"}"}
private emitChangedEvent(String n,def v,String d=null,String u=null){def o=device.currentValue(n);if(o?.toString()!=v?.toString()){sendEvent(name:n,value:v,unit:u,descriptionText:d);logInfo d?"${n}=${v} (${d})":"${n}=${v}"}else logDebug"No change for ${n} (still ${o})"}
private parseIfString(o,c="response"){(o instanceof String)?(new groovy.json.JsonSlurper().parseText(o)):o}
private extractHexData(resp){def p=parseIfString(resp);return p?.result?.data?:null}
def autoDisableDebugLogging(){try{unschedule(autoDisableDebugLogging);device.updateSetting("logEnable",[value:"false",type:"bool"]);logInfo"Debug logging disabled (auto)"}catch(e){logDebug"autoDisableDebugLogging(): ${e.message}"}}
def disableDebugLoggingNow(){try{unschedule(autoDisableDebugLogging);device.updateSetting("logEnable",[value:"false",type:"bool"]);logInfo"Debug logging disabled (manual)"}catch(e){logDebug"disableDebugLoggingNow(): ${e.message}"}}

/* =============================== Lifecycle =============================== */
def installed(){log.info "Installed. ${driverInfoString()}";initialize()}
def updated(){logInfo "Preferences updated.";unschedule();configure()}
def configure(){logInfo "Configured.";zoneCount=zonePref;unschedule();initialize()}
def initialize(){
    reconnoiter=true;state.failCount=0;emitEvent("driverInfo",driverInfoString());logDebug"IP=${ipAddress}, Password=${password}"
    if(ipAddress&&password){
        unschedule(autoDisableDebugLogging)
        if(logEnable)runIn(1800,autoDisableDebugLogging)
        driverStatus();getControllerIdentity();scheduleRefresh()
        if(refreshInterval?.toInteger()==0&&autoTimeSync){
            def cron="0 0 * ? * *"
            try{
                schedule(cron,"checkAndSyncClock");logInfo"Manual refresh mode active; hourly clock drift check scheduled (${cron})"
            }catch(e){logError"Failed to schedule clock sync CRON: ${e.message}"}
        }
        reconnoiter=false;runInMillis(500,"refresh")
    }
    else logWarn"Cannot initialize. Preferences must be set."
}

/* =============================== Driver Maintenance =============================== */
def driverStatus(String controllerContext=null){
    logDebug"Starting driver self-test sequence..."
    def results=[]
    [["4C","Status"],["10","Time"],["12","Date"]].each{k,v->
        try{def r=parseIfString(sendRainbirdCommand(k,1),"driverStatus-${v}");results<< (r?"${v} OK":"${v} FAIL (no response)")}
        catch(e){results<<"${v} FAIL (${e.message})"}
    }
    def baseStatus=results.join(" | ")
    if(controllerContext)baseStatus+=" | ${controllerContext}"
    def fails=state.failCount?:0
    if(fails>3)baseStatus+=" | Network Degraded (${fails} fails)"
    else if(fails>0)baseStatus+=" | ${fails} recent fail${fails>1?'s':''}"
    return baseStatus
}

private boolean isLegacyFirmware(BigDecimal minVersion=3.0){
    try{
        def pvAttr=device.currentValue("firmwareVersion")
        if(!pvAttr){logDebug"isLegacyFirmware(): firmwareVersion not yet available (initializing — deferring legacy check)";return false}
        def pv=pvAttr.toString().replaceAll("[^0-9.]","").toBigDecimal()
        return pv<minVersion
    }catch(e){logWarn"Firmware version check failed: ${e.message}";return true}
}

def getCommandSupport(cmdToTest="4A"){
    logDebug"Querying command support for 0x${cmdToTest.toUpperCase()}..."
    try{
        def cmd="04${cmdToTest.padLeft(2,'0')}00";def r=parseIfString(sendRainbirdCommand(cmd,2),"getCommandSupport")
        def d=r?.result?.data
        if(!d){logWarn"getCommandSupport(): No valid response";return false}
        if(d.startsWith("84")){
            def echo=d.substring(2,4);def support=Integer.parseInt(d.substring(4,6),16);def supported=(support==1)
            logDebug"Command 0x${echo} is ${supported ? 'supported' : 'not supported'} by controller";return supported
        }else{logWarn"getCommandSupport(): Unexpected data (${d})";return false}
    }catch(e){logError"getCommandSupport() failed: ${e.message}";return false}
}


def testAllSupportedCommands(){
    logInfo"Running full command support diagnostic..."
    def cmds=["02","03","04","05","10","12","30","32","36","37","38","39","3A","3E","3F","40","42","48","49","4A","4B","4C"];def results=[:]
    cmds.each{c->
        try{
            def r=parseIfString(sendRainbirdCommand("04${c}00",2),"testCommandSupport-${c}");def d=r?.result?.data
            if(d?.startsWith("84")){
                def supported=Integer.parseInt(d.substring(4,6),16)==1;results[c]=supported
                logDebug"Command 0x${c} → ${supported?'supported':'not supported'}"
            }else results[c]="?"
        }catch(e){results[c]="ERR";logWarn"testAllSupportedCommands(): 0x${c} failed (${e.message})"}
    }
    def supported=results.findAll{k,v->v==true}.collect{k->"0x${k}"};def unsupported=results.findAll{k,v->v==false}.collect{k->"0x${k}"};def unknown=results.findAll{k,v->v in ["?","ERR"]}.collect{k->"0x${k}"}
    def summary="Supported: ${supported.join(', ')?:'none'} | Unsupported: ${unsupported.join(', ')?:'none'} | Unknown: ${unknown.join(', ')?:'none'}"
    emitEvent("commandSupport",summary,"Command support diagnostic complete.")
}

/* =============================== Manual Irrigation Control =============================== */
def runZone(zone,duration){
    zone=Math.max(1,Math.min(zoneCount?:1,(zone?:1).toInteger()))
    duration=Math.max(1,Math.min(120,(duration?:1).toInteger()))
    def cmd="39${sprintf('%04x',zone)}${sprintf('%02x',duration)}"
    logDebug"Starting zone ${zone} for ${duration} minute(s) (encoded ${cmd})"
    try{
        def r=parseIfString(sendRainbirdCommand(cmd,4),"runZone")
        def d=r?.result?.data
        if(!d){logWarn"runZone(): Empty response";return}
        if(d.reverse().endsWith("10")){
            emitEvent("activeZone",zone);emitEvent("watering",true,"Zone ${zone} started successfully")
        }else logWarn"runZone(): Controller did not acknowledge (data=${d})"
    }catch(e){logError"runZone() failed: ${e.message}"}
    runInMillis(1000,"refresh")
}

def stopZone(zone){
    zone=Math.max(1,Math.min(zoneCount?:1,(zone?:1).toInteger()))
    def cmd="42${sprintf('%04x',zone)}"
    logDebug"Stopping irrigation for zone ${zone} (encoded ${cmd})"
    try{
        def r=parseIfString(sendRainbirdCommand(cmd,2),"stopZone");def d=r?.result?.data
        if(!d){logWarn"stopZone(): Empty response";return}
        if(d.reverse().endsWith("10"))emitEvent("activeZone",0,"Zone ${zone} stopped successfully")
        else logWarn"stopZone(): Controller did not acknowledge (data=${d})"
    }catch(e){logError"stopZone() failed: ${e.message}"}
    runInMillis(1000,"refresh")
}

def stopIrrigation(){
    def cmd="40"
    logDebug"Stopping all irrigation (encoded ${cmd})"
    try{
        def r=parseIfString(sendRainbirdCommand(cmd,1),"stopIrrigation");def d=r?.result?.data
        if(!d){logWarn"stopIrrigation(): Empty response";return}
        if(d.reverse().endsWith("10")){
            emitEvent("activeZone",0)
            emitEvent("watering",false,"All irrigation stopped successfully")
        }else logWarn"stopIrrigation(): Controller did not acknowledge (data=${d})"
    }catch(e){logError"stopIrrigation() failed: ${e.message}"}
    runInMillis(1000,"refresh")
}

def getAvailableStations(){
    def pv=device.currentValue("firmwareVersion")
    if(!pv){logDebug"getAvailableStations(): firmwareVersion not yet available; deferring request until identity is known.";return}
    def pvNum=pv.toString().replaceAll("[^0-9.]","").toBigDecimal()
    if(pvNum<3.0)logDebug"getAvailableStations(): Detected legacy firmware ${pvNum}, probing for hybrid opcode support..."
    else logDebug"Requesting available stations (firmware=${pvNum})..."
    try{
        def r=parseIfString(sendRainbirdCommand("030000",2),"getAvailableStations")
        def d=r?.result?.data
        if(!d){logWarn"getAvailableStations: No valid response";return}
        if(d.startsWith("83")){
            def bitmask=d.substring(4,12);def maskInt=Integer.parseInt(bitmask,16)
            def available=(1..bitmask.size()*4).findAll{i->(maskInt&(1<<(i-1)))!=0}.collect{idx->(idx>24&&idx<=31)?(idx-24):idx}
            emitChangedEvent("availableStations",available.join(","),"Available stations: ${available.join(', ')}")
            def actualCount=available.size();def currentAttr=device.currentValue("zoneCount")?.toInteger()?:0
            if(actualCount&&actualCount!=currentAttr){
                zoneCount=actualCount
                emitChangedEvent("zoneCount",actualCount,"Zone count updated dynamically to ${actualCount} (controller)")
                logDebug"zoneCount updated dynamically from controller data: ${actualCount}"
            }
            if(pvNum<3.0)logDebug"Hybrid opcode support detected on legacy firmware ${pvNum} (0x03 → 0x83 success)."
        }else logWarn"getAvailableStations: Unexpected data (${d})"
    }catch(e){logError"getAvailableStations() failed: ${e.message}"}
}

def getWaterBudget(){
    logDebug"Requesting water budget..."
    try{
        def r=parseIfString(sendRainbirdCommand("300000",2),"getWaterBudget")
        def d=r?.result?.data
        if(!d){logWarn"getWaterBudget: No valid response";return}
        if(d.startsWith("B0")){
            def pct=Integer.parseInt(d.substring(4,8),16)
            emitChangedEvent("waterBudget",pct,"Water budget: ${pct}%","%")
        }else logWarn"getWaterBudget: Unexpected data (${d})"
    }catch(e){logError"getWaterBudget() failed: ${e.message}"}
}

def getZoneSeasonalAdjustments(){
    if(isLegacyFirmware(3.1)){logDebug"Skipping getZoneSeasonalAdjustments(): requires firmware ≥3.1";return}
    logDebug"Requesting per-zone seasonal adjustments..."
    try{
        def r=parseIfString(sendRainbirdCommand("320000",2),"getZoneSeasonalAdjustments")
        def d=r?.result?.data
        if(!d){logWarn"getZoneSeasonalAdjustments: No valid response";return}
        if(d.startsWith("B2")){
            def hex=d.substring(4);def zones=[]
            for(int i=0;i<hex.length();i+=4){
                def pct=Integer.parseInt(hex.substring(i,i+4),16)
                zones<<"${(i/4)+1}:${pct}%"
            }
            emitChangedEvent("zoneAdjustments",zones.join(","),"Zone adjustments: ${zones.join(', ')}")
        }else logWarn"getZoneSeasonalAdjustments: Unexpected data (${d})"
    }catch(e){logError"getZoneSeasonalAdjustments() failed: ${e.message}"}
}

def getRainSensorState(){
    logDebug"Requesting rain sensor state..."
    try{
        def r=parseIfString(sendRainbirdCommand("3E",1),"getRainSensorState")
        def d=r?.result?.data
        if(!d){logWarn"getRainSensorState: No valid response";return}
        if(d.startsWith("BE")){
            def s=Integer.parseInt(d.substring(2,4),16)
            def stateStr=(s==0)?"Dry":(s==1?"Wet":"Bypassed")
            emitChangedEvent("rainSensorState",stateStr,"Rain sensor state: ${stateStr}")
        }else logWarn"getRainSensorState: Unexpected data (${d})"
    }catch(e){logError"getRainSensorState() failed: ${e.message}"}
}

def getControllerEventTimestamp(){
    if(isLegacyFirmware(4.0)){logDebug"Skipping getControllerEventTimestamp(): requires firmware ≥4.0";return}
    logDebug"Requesting controller event timestamp..."
    try{
        def r=parseIfString(sendRainbirdCommand("4A0000",2),"getControllerEventTimestamp")
        def d=r?.result?.data
        if(!d){logWarn"getControllerEventTimestamp: No valid response";return}
        if(d.startsWith("CA")){
            def ts=d.substring(4,12);def seconds=Long.parseLong(ts,16);def date=new Date(seconds*1000)
            def fmt=new java.text.SimpleDateFormat("yyyy-MM-dd HH:mm:ss");fmt.setTimeZone(location.timeZone)
            emitChangedEvent("lastEventTime",fmt.format(date),"Controller event timestamp: ${fmt.format(date)}")
        }else logWarn"getControllerEventTimestamp: Unexpected data (${d})"
    }catch(e){logError"getControllerEventTimestamp() failed: ${e.message}"}
}

def runProgram(programCode){
    if(!programCode){logWarn"runProgram(): No program specified.";return}
    def map=["A":0,"B":1,"C":2,"D":3]
    def code=map.get(programCode.toString().toUpperCase(),1)
    def cmd="38${sprintf('%02x00',code)}"
    logDebug"Manually starting Rain Bird Program ${programCode} (encoded ${cmd})"
    try{
        def r=parseIfString(sendRainbirdCommand(cmd,2),"runProgram");def d=r?.result?.data
        if(!d){logWarn"runProgram(): Empty response";return}
        if(d.startsWith("01")) {
            emitChangedEvent("controllerState","Manual Program ${programCode}","Manual program ${programCode} started.")
        } else if(d.startsWith("00") && d.endsWith("04")) {
            logWarn"runProgram(): Program ${programCode} is either undefined and/or contains no zones (ignored by controller)."
        } else {
            logWarn"runProgram(): Unexpected ACK/NAK (${d})"
        }
    }catch(e){logError"runProgram() failed: ${e.message}"}
}

private isStubProgramResponse(hex){return["003A02","003802","B60000"].contains(hex)}

def getProgramSchedule(prog='A'){
    if(isLegacyFirmware(2.5)){logDebug"Skipping getProgramSchedule(): requires firmware ≥2.6";return false}
    def map=["A":0,"B":1,"C":2,"D":3];def pid=map[prog?.toUpperCase()]
    if(pid==null){logWarn"Invalid program ${prog}";return false}
    if(!getCommandSupport("36")){logWarn"Program ${prog} schedule query not supported on this controller.";emitEvent("programScheduleSupport",false);return}
    logDebug"Requesting schedule for program ${prog}..."
    try{
        def t=parseIfString(sendRainbirdCommand(String.format("36%02X",pid),1),"getProgramStartTimes")
        def d=parseIfString(sendRainbirdCommand(String.format("38%02X",pid),1),"getProgramDays")
        def z=parseIfString(sendRainbirdCommand(String.format("3A%02X",pid),1),"getProgramZones")
        def tData=t?.result?.data;def dData=d?.result?.data;def zData=z?.result?.data
        logDebug"Raw data (start times): ${tData}";logDebug"Raw data (days): ${dData}";logDebug"Raw data (zones): ${zData}"
        if(isStubProgramResponse(tData)&&isStubProgramResponse(dData)&&isStubProgramResponse(zData)){
            logWarn"Program ${prog} query acknowledged but data unavailable (firmware ${device.currentValue('firmwareVersion')})."
            return false
        }
        def times=parseProgramTimes(tData);def days=parseProgramDays(dData);def zones=parseProgramZones(zData)
        logInfo"Program ${prog}: ${days} | ${times} | Zones ${zones}"
        emitEvent("program${prog}_days",days);emitEvent("program${prog}_startTimes",times.join(', '));emitEvent("program${prog}_zones",zones.join(', '))
        return (times||days||zones)
    }catch(e){logError"getProgramSchedule(${prog}) failed: ${e.message}";return false}
}

def getAllProgramSchedules(){
    if(isLegacyFirmware(2.5)){logDebug"Skipping getAllProgramSchedules(): requires firmware ≥2.6";emitEvent("programScheduleSupport",false);return}
    if(!getCommandSupport("36")){logWarn"Program schedule query not supported on this controller";emitEvent("programScheduleSupport",false);return}
    logDebug"Retrieving all available program schedules..."
    def supported=["A","B","C","D"].collect{getProgramSchedule(it)}.any{it}
    emitEvent("programScheduleSupport",supported)
}

/* =============================== Rain Delay Control =============================== */
def getRainDelay(){
    logDebug"Requesting current rain delay..."
    try{
        def r=parseIfString(sendRainbirdCommand("36",1),"getRainDelay")
        def d=r?.result?.data
        if(!d){logWarn"getRainDelay: No valid response";return}
        if(d.startsWith("36")&&d.size()>=6){
            def delay=Integer.parseInt(d.substring(2,6),16)
            emitChangedEvent("rainDelay",delay,"Controller rain delay: ${delay} day(s)","d")
        }else if(d.startsWith("B6")&&d.size()>=6){
            def delay=Integer.parseInt(d.substring(2,6),16)
            emitChangedEvent("rainDelay",delay,"Controller rain delay: ${delay} day(s) [variant response]","d")
        }else logWarn"getRainDelay: Unexpected data format (${d})"
    }catch(e){logError"getRainDelay() failed: ${e.message}"}
}

def setRainDelay(days){
    def original=days;days=Math.max(0,Math.min(14,(days?:0).toInteger()))
    if(original!=days)logWarn"Adjusted rain delay from ${original} to ${days} (clamped 0–14)"
    def cmd="37${sprintf('%04X',days)}".toUpperCase()
    logDebug"Setting rain delay to ${days} day(s) (encoded ${cmd})"
    try{
        def r=parseIfString(sendRainbirdCommand(cmd,3),"setRainDelay")
        def d=r?.result?.data
        if(!d){logWarn"setRainDelay: Empty response";return}
        if(d.endsWith("37")||d.endsWith("10"))emitChangedEvent("rainDelay",days,"Rain delay updated to ${days} day(s)","d")
        else logWarn"setRainDelay: Unexpected ACK response: ${d}"
    }catch(e){logError"setRainDelay() failed: ${e.message}"}
    runInMillis(1000,"getRainDelay")
}

/* =============================== Time / Date =============================== */
def getControllerTime(){logDebug"Requesting controller time...";parseTimeResponse(parseIfString(sendRainbirdCommand("10",1),"getControllerTime"));if(autoTimeSync)runInMillis(250,"checkAndSyncClock")}
def getControllerDate(){logDebug"Requesting controller date...";parseDateResponse(parseIfString(sendRainbirdCommand("12",1),"getControllerDate"))}
def setControllerDate(){logInfo"Controller date reporting only (LNK ignores SetDate)";getControllerDate()}
def setControllerTime(){
    def now=new Date();def cmd="11${sprintf('%02x',now.format('HH',location.timeZone).toInteger())}${sprintf('%02x',now.format('mm',location.timeZone).toInteger())}${sprintf('%02x',now.format('ss',location.timeZone).toInteger())}"
    logDebug"Setting controller time (encoded ${cmd})"
    parseIfString(sendRainbirdCommand(cmd,4),"setControllerTime");getControllerTime()
}

private parseControllerTimeToDate(timeStr){
    if(!timeStr)return null
    try{
        def p=timeStr.split(":")*.toInteger();def n=new Date()
        return new Date(n.year,n.month,n.date,p[0],p[1],p[2])
    }catch(e){logWarn"parseControllerTimeToDate() failed: ${e.message}";return null}
}

private buildTimeCommand(Date dt){
    try{
        def h=sprintf("%02X",dt.format("HH").toInteger())
        def m=sprintf("%02X",dt.format("mm").toInteger())
        def s=sprintf("%02X",dt.format("ss").toInteger())
        def cmd="10${h}${m}${s}";logDebug"buildTimeCommand(): ${cmd}";return cmd
    }catch(e){logError"buildTimeCommand() failed: ${e.message}";return null}
}

// Adaptive RainBird Clock Drift Correction
private checkAndSyncClock(){
    if(!autoTimeSync)return
    try{
        def cDate=device.currentValue("controllerDate");def cTime=device.currentValue("controllerTime")
        if(!cDate||!cTime){logDebug"checkAndSyncClock(): missing controller date/time";return}
        def fmt=new java.text.SimpleDateFormat("yyyy-MM-dd HH:mm:ss");fmt.setTimeZone(location.timeZone)
        def parsed=fmt.parse("${cDate} ${cTime}");if(!parsed){logWarn"checkAndSyncClock(): parse failed for ${cDate} ${cTime}";return}
        def controllerEpoch=parsed.time;def hubNow=now()
        def clockDrift=(int)(Math.abs((hubNow.intdiv(1000))-(controllerEpoch.intdiv(1000))))
        def dstAdj=(clockDrift>=3595&&clockDrift<=3605)
        def desc=dstAdj?"Daylight Saving Time adjustment detected.":"Clock drift: ${clockDrift}s"
        emitChangedEvent("clockDrift",clockDrift,desc,"s")
        if(!dstAdj&&clockDrift>=5)syncRainbirdClock(clockDrift)
    }catch(e){logError"checkAndSyncClock(): ${e.message}"}
}

private syncRainbirdClock(drift){
    try{
        def tz=location?.timeZone?:TimeZone.getDefault()
        def fmt=new java.text.SimpleDateFormat(dateFormat?:"yyyy-MM-dd HH:mm:ss");fmt.setTimeZone(tz)
        def now=new Date();def nowStr=fmt.format(now);def cmd=buildTimeCommand(now)
        if(cmd){
            sendRainbirdCommand(cmd,5)
            emitEvent("lastSync", nowStr, "Clock synchronized at ${nowStr} (drift ${drift}s corrected)")
            logInfo"Controller clock synchronized | Drift corrected: ${drift}s";runIn(30,"verifyClockUpdate")
        }
    }catch(e){logError"syncRainbirdClock() failed: ${e.message}"}
}

private verifyClockUpdate(){
    logDebug"Verifying RainBird clock after sync commit..."
    def prev=device.currentValue("controllerTime")
    getControllerTime();def newVal=device.currentValue("controllerTime")
    if(prev!=newVal){
        emitChangedEvent("clockDrift",0,"Controller clock verified updated.","s");logInfo"Controller clock verification successful."
    }else logWarn"Controller clock unchanged; verification deferred to next CRON refresh."
}

/* =============================== Refresh & Scheduling =============================== */
def refresh(){
	if(reconnoiter){logDebug"Refresh skipped; another refresh in progress.";return}
	atomicState.refreshPending=false;def nowEpoch=now()
    if (nowEpoch-lastRefreshEpoch<REFRESH_GUARD_MS) {logDebug"Refresh skipped; last run ${(nowEpoch - lastRefreshEpoch) / 1000}s ago.";return}
	reconnoiter=true;lastRefreshEpoch=nowEpoch
	if(!ipAddress||!password){logWarn"Cannot refresh. Preferences must be set and driver initialized.";reconnoiter=false;return}
	def min=refreshInterval.toInteger();def failCount=state.failCount?:0
	if(failCount>=10){logWarn"Too many consecutive failures (${failCount}). Forcing reinitialization.";state.failCount=0;runIn(5,"initialize");reconnoiter=false;return}
	if(failCount>3){
		def backoff=Math.min(1800,300*failCount)
		if(!atomicState.refreshPending){atomicState.refreshPending=true
		    logWarn"Network instability detected. Backing off refresh to ${backoff}s.";runIn(backoff, "refresh")
		}else{logDebug"Backoff already pending; skipping duplicate scheduling."}
		reconnoiter=false;return
	}
	def cron="0 0/${min} * ? * *";logDebug"Refreshing RainBird controller (CRON=${cron})"
	try{
		driverStatus();def r=parseIfString(sendRainbirdCommand("4C",1),"refresh")
		if(r)parseCombinedControllerState(r)
		getRainSensorState();getWaterBudget();getRainDelay();getZoneSeasonalAdjustments()
		getAvailableStations();getControllerEventTimestamp();getControllerDate();getControllerTime()
		logDebug"Zones: ${device.currentValue('availableStations')?:'None'} | Rain Delay: ${device.currentValue('rainDelay')} | FailCount: ${failCount}"
		state.failCount=0;atomicState.refreshPending=false
	}catch(e){state.failCount=(state.failCount?:0)+1;logError"Refresh failed (${state.failCount}): ${e.message}"}
	finally{reconnoiter=false}
}

private scheduleRefresh(){
    unschedule("refresh");def min=refreshInterval.toInteger()
    try{
        def cron=(min==0)?"manual":(min<60)?"0 0/${min} * ? * *":"0 0 0/${(min/60).toInteger()} ? * *"
        if(cron!="manual"){
            schedule(cron,"refresh");logInfo"Controller refresh scheduled: ${cron}"
        }else logInfo"Manual refresh mode active; refresh not scheduled."
    }catch(e){logError"Failed to schedule refresh: ${e.message}"}
}

/* =============================== Parsing Helpers =============================== */
private parseTimeResponse(resp){
    if(!resp)return
    try{
        def data=(resp instanceof Map)?resp?.result?.data:(resp instanceof String?(resp=~/"data":"(.*?)"/)?[0][1]:null:null)
        if(!data){logWarn"parseTimeResponse(): no valid data";return}
        if(data.length()>=8&&data.startsWith("90")){
            def h=Integer.parseInt(data[2..3],16);def m=Integer.parseInt(data[4..5],16);def s=Integer.parseInt(data[6..7],16)
            def t=sprintf("%02d:%02d:%02d",h,m,s);emitChangedEvent("controllerTime",t,"${device.currentValue('controllerDate')?:''} ${t}".trim())
        }
    }catch(e){logWarn"parseTimeResponse() failed: ${e.message}"}
}

private parseDateResponse(resp){
    if(!resp)return
    try{
        def data=(resp instanceof Map)?resp?.result?.data:(resp instanceof String?(resp=~/"data":"(.*?)"/)?[0][1]:null:null)
        if(!data){logWarn"parseDateResponse(): no valid data";return}
        if(data.length()>=8&&data.startsWith("92")){
            def d=Integer.parseInt(data[2..3],16);def m=Integer.parseInt(data[4..4],16);def y=Integer.parseInt(data[5..7],16)
            def dt=sprintf("%04d-%02d-%02d",y,m,d);emitChangedEvent("controllerDate",dt,"${dt} ${device.currentValue('controllerTime')?:''}".trim())
        }
    }catch(e){logWarn"parseDateResponse() failed: ${e.message}"}
}

private getControllerIdentity(){
    logDebug"Requesting controller identity (model/firmware/serial)..."
    try{
        def r02=parseIfString(sendRainbirdCommand("02",1),"getControllerIdentity-Model")
        def data02=extractHexData(r02)
        def modelID="Unknown";def fwareVersion="Unknown"
        if(data02?.reverse()?.endsWith("28")){
            modelID=data02.substring(2,6)
            def fwareMaj=Integer.parseInt(data02.substring(6,8),16)
            def fwareMin=Integer.parseInt(data02.substring(8,10),16)
            fwareVersion="${fwareMaj}.${fwareMin}"
            logDebug"Parsed 0x82 → modelID=${modelID}, firmware=${fwareVersion}"
        }else logWarn"ModelAndVersionRequest failed: ${data02}"
        def r05=parseIfString(sendRainbirdCommand("05",1),"getControllerIdentity-Serial")
        def data05=extractHexData(r05)
        def serial="Unavailable"
        if(data05?.reverse()?.endsWith("58")){
            serial=data05.substring(2)
            logDebug"Parsed 0x85 → serial=${serial}"
        }else logWarn"SerialNumberRequest failed: ${data05}"
        emitChangedEvent("model","RainBird ${modelID}","Controller model: RainBird ${modelID}")
        emitChangedEvent("serialNumber",serial,"Controller serial number: ${serial}")
        emitChangedEvent("firmwareVersion",fwareVersion,"Firmware version: ${fwareVersion}")
    }catch(e){logError"getControllerIdentity() failed: ${e.message}"}
}

private parseCombinedControllerState(resp,boolean summaryOnly=false){
    try{
        def hex=extractHexData(resp)
        logDebug"parseCombinedControllerState(): raw data=${hex}"
        if(!hex){logWarn"parseCombinedControllerState(): no valid data";return}
        if(hex.startsWith("004C")){
		    def status=hex[-2..-1]
		    def irrigationText=(status=="02"?"Watering":status=="01"?"Idle":status=="03"?"Rain Delay":"Unknown (${status})")
		    emitChangedEvent("irrigationState",irrigationText,"Irrigation state: ${irrigationText}")
		    emitChangedEvent("controllerState",irrigationText,"Controller state: ${irrigationText}")
		    emitChangedEvent("watering",(status=="02"),"Watering: ${status=='02'}")
		    if(status=="01")emitChangedEvent("activeZone",0,"No active zones")
		    def base=driverStatus()
		    emitChangedEvent("driverStatus","${base} | Controller ${irrigationText}","${base} | Controller ${irrigationText}")
		    return
		}
        if(!hex.startsWith("CC"))return
        try{
            def hour=Integer.parseInt(hex[2..3],16)
            def minute=Integer.parseInt(hex[4..5],16)
            def second=Integer.parseInt(hex[6..7],16)
            def day=Integer.parseInt(hex[8..9],16)
            def month=Integer.parseInt(hex[10..10],16)
            def year=2000+Integer.parseInt(hex[11..13],16)
            def delay=Integer.parseInt(hex[14..17],16)
            def sensor=Integer.parseInt(hex[18..19],16)
            def irrig=Integer.parseInt(hex[20..21],16)
            def season=Integer.parseInt(hex[22..25],16)
            def remain=Integer.parseInt(hex[26..29],16)
            def zone=Integer.parseInt(hex[30..31],16)
            def irrigationText=(irrig==1?"Watering":irrig==0?"Idle":irrig==2?"Rain Delay":"Unknown (${irrig})")
            def watering=(irrig==1)
            def timeStr=sprintf("%02d:%02d:%02d",hour,minute,second)
            def dateStr=sprintf("%04d-%02d-%02d",year,month,day)
            emitChangedEvent("controllerTime",timeStr,"Controller time=${timeStr}")
            emitChangedEvent("controllerDate",dateStr,"Controller date=${dateStr}")
            emitChangedEvent("delaySetting",delay,"Rain delay=${delay}")
            emitChangedEvent("rainSensorState",sensor,"Sensor state=${sensor}")
            emitChangedEvent("irrigationState",irrigationText,"Irrigation state=${irrigationText}")
            emitChangedEvent("seasonalAdjust",season,"Seasonal adjust=${season}%","%")
            emitChangedEvent("remainingRuntime",remain,"Remaining runtime=${remain}s")
            emitChangedEvent("activeZone",zone,"Active zone=${zone}")
            emitChangedEvent("watering",watering,"Watering=${watering}")
            emitChangedEvent("controllerState",irrigationText,"Controller state=${irrigationText}")
            def base=driverStatus()
            if(irrigationText&&irrigationText!="Unknown")
                emitChangedEvent("driverStatus","${base} | Controller ${irrigationText}","driverStatus=${base} | Controller ${irrigationText}")
            else{
                logDebug"parseCombinedControllerState(): no valid irrigation status (hex=${hex?:'null'})"
                emitChangedEvent("driverStatus","${base} | Controller Status Unknown","driverStatus=${base} | Controller Status Unknown")
            }
            if(summaryOnly)return"Time:${timeStr}, Date:${dateStr}, Zone:${zone}, Runtime:${remain}s, Delay:${delay}, SeasonAdj:${season}%"
        }catch(e){logWarn"parseCombinedControllerState() inner parse failed: ${e.message}"}
    }catch(e){
        emitChangedEvent("driverStatus","Status FAIL | Combined State Parse Error","Combined state parse error")
        logError"parseCombinedControllerState() failed: ${e.message}"
    }
}

private parseProgramTimes(hex){
    if(!hex){logWarn"parseProgramTimes(): No data";return[]}
    if(hex.length()<=6){logWarn"parseProgramTimes(): Legacy short response (${hex}) – no start times defined";return[]}
    def payload=hex.substring(hex.length()-12)
    def times=[]
    (0..<payload.length()).step(4).each{i->
        def hh=Integer.parseInt(payload.substring(i,i+2),16)
        def mm=Integer.parseInt(payload.substring(i+2,i+4),16)
        if(hh<24&&mm<60)times<<String.format('%02d:%02d',hh,mm)
    }
    return times
}

private parseProgramDays(hex){
    if(!hex){logWarn"parseProgramDays(): No data";return'Unknown'}
    def mask=Integer.parseInt(hex.substring(hex.length()-2),16)
    def days=['Sun','Mon','Tue','Wed','Thu','Fri','Sat']
    def active=(0..6).collect{mask&(1<<it)?days[it]:null}.findAll{it}
    return active?active.join(', '):'None'
}

private parseProgramZones(hex){
    if(!hex){logWarn"parseProgramZones(): No data";return[]}
    def mask=Integer.parseInt(hex.substring(hex.length()-2),16)
    def zones=(1..8).collect{mask&(1<<(it-1))?it:null}.findAll{it}
    return zones
}

/* =============================== Communication / Crypto =============================== */
private sendRainbirdCommand(cmdHex, length=1){
	if(cmdBusy){logDebug"Command skipped; another command already in progress (${cmdHex})";return null}
	cmdBusy = true;def result = null
	try{
		def id=Math.floor(now()/1000)
		def payload=JsonOutput.toJson([id:id,jsonrpc:"2.0",method:"tunnelSip",params:[data:cmdHex,length:length]])
		def enc=encryptRainbird(payload,password)
		def params=[uri:"http://${ipAddress}/stick",contentType:"application/octet-stream",requestContentType:"application/octet-stream",body:enc]
		def response=null
		httpPost(params){resp->
			response=decryptRainbird(resp.data.bytes,password)
		}
		if(response){
			successStreak=Math.min(successStreak+1,10)
			if(successStreak>5&&delayMs>minDelay)delayMs=Math.max(minDelay,delayMs-10)
			result=response;state.failCount=0
		}else{
			successStreak=0;delayMs=Math.min(maxDelay,delayMs+50)
			state.failCount=(state.failCount?:0)+1;logWarn"sendRainbirdCommand(): No valid response"
		}
	}catch(e){
		logWarn"sendRainbirdCommand() exception: ${e.message}"
	}finally{
		cmdBusy=false
	}
	return result
}

def encryptRainbird(String json,String pwd){
    try{
        def sha=SHA256.clone()
        byte[]kb=sha.digest(pwd.getBytes("UTF-8"))
        def key=new SecretKeySpec(kb,"AES")
        byte[]iv=new byte[BLOCK_SIZE];new Random().nextBytes(iv)
        def ivs=new IvParameterSpec(iv)
        String msg=padToBlock(json+"\u0000\u0016")
        def cipher=AES_CIPHER;cipher.init(Cipher.ENCRYPT_MODE,key,ivs)
        byte[]enc=cipher.doFinal(msg.getBytes("UTF-8"))
        byte[]mh=sha.digest(json.getBytes("UTF-8"))
        def o=new ByteArrayOutputStream();o.write(mh);o.write(iv);o.write(enc);return o.toByteArray()
    }catch(e){logError"encryptRainbird error: ${e.message}";return new byte[0]}
}

def decryptRainbird(byte[]cb,String pwd){
    try{
        if(!cb||cb.length<48)return""
        byte[]iv=cb[32..47]as byte[];byte[]d=cb[48..cb.length-1]as byte[]
        def sha=SHA256.clone()
        byte[]kb=sha.digest(pwd.getBytes("UTF-8"))
        def key=new SecretKeySpec(kb,"AES")
        def ivs=new IvParameterSpec(iv)
        def cipher=AES_CIPHER;cipher.init(Cipher.DECRYPT_MODE,key,ivs)
        String dec=new String(cipher.doFinal(d),"UTF-8")
        dec=dec.replaceAll("\u0000","").replaceAll(PAD,"")
        return dec
    }catch(e){logError"decryptRainbird error: ${e.message}";return""}
}

def padToBlock(String s){int r=s.length()%BLOCK_SIZE;if(r==0)return s;int p=BLOCK_SIZE-r;return s+(PAD*p)}
